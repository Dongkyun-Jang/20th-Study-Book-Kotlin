# Kotlin in acion - Chapter 3. 함수 정의와 호출

<br>

## 3.1 코틀린에서 컬렉션 만들기

- 코틀린은 자체 컬렉션 기능을 제공하지 않고, 표준 자바 컬렉션을 그대로 이용한다
    - 자바와 코틀린 간의 컬렉션 변환이 필요 없다
- 하지만 코틀린에서는 다양한 확장 함수로 인해 자바보다 훨씬 더 많은 컬렉션 기능을 이용할 수 있다

<br>

## 3.2 함수를 호출하기 쉽게 만들기

```kotlin
fun <T> joinToString(
    collection: Collection<T>,
    separator: String,
    prefix: String,
    postfix: String
) {
    // . . .
}
```

<br>

### 3.2.1 이름 붙인 인자

위의 메서드를 호출하려면 `joinToString(collection, " ", " ", ".")` 와 같은 코드를 작성해야 한다.

그러나 함수에 전달하는 인자 중 일부 또는 전부의 이름을 명시함으로써 다음과 같이 함수 호출의 가독성을 다음과 같이 높일 수 있다

`joinToString(collection, separator = " ", prefix = " ", postfix = ".")`

> 이때, 호출 시 인자 중 어느 하나라도 이름을 명시하고 나면 혼동을 막기 위해 그 뒤에 오는 모든 인자는 이름을 꼭 명시해야 한다.

<br>

### 3.2.2 디폴트 파라미터 값

```kotlin
fun <T> joinToString(
    collection: Collection<T>,
    separator: String = ", ",
    prefix: String = "",
    postfix: String = ""
) {
    // . . .
}
```

위와 같이 함수 선언에서 파라미터의 디폴트 값을 지정하면 불필요한 오버로딩을 피할 수 있다.

`joinToString(list, "; ")` - separator를 "; "로 지정, prefix와 postfix 생략

<br>

### 3.2.3 정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티

- 코틀린은 자바와 다르게, 모든 코드를 클래스의 메서드로 작성하지 않아도 된다
- 코틀린은 함수를 직접 소스 파일의 최상위 수준, 즉 모든 다른 클래스의 밖에 위치시킬 수 있다
- 실제 컴파일 결과는 메서드가 정의된 파일명으로 클래스를 만들고 그 안에 선언한다
- 함수 뿐만 아니라 프로퍼티 또한 최상위 수준에 위치시킬 수 있다

코틀린의 `const` == 자바의 `public static final`

이때, 원시 타입과 String 타입의 프로퍼티만 `const`로 지정할 수 있다

<br>

## 3.3 메서드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티

- 확장 함수 및 확장 프로퍼티를 이용하면, 기존 자바 API를 재작성하지 않고도 추가 기능들을 이용할 수 있다
- 확장 함수를 만들려면 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이기만 하면 된다
  - 클래스 이름: **수신 객체 타입(receiver type)**
  - 확장 함수가 호출되는 대상이 되는 값 또는 객체: **수신 객체(receiver object)**
- 확장 함수 내부에서는 일반적인 인스턴스 메서드의 내부에서와 마찬가지로 수신 객체의 메서드나 프로퍼티 이용 가능
  - 다만, 확장 함수가 캡슐화를 깨지는 않기 때문에 private 또는 protected 멤버를 이용할 순 없음
- 함수를 호출하는 쪽에서는 수신 객체의 멤버 메서드와 확장 함수를 구분할 수 없다

<br>

### 3.3.3 확장 함수로 유틸리티 함수 정의

```kotlin
fun <T> Collection<T>.joinToString(
    collection: Collection<T>,
    separator: String = ", ",
    prefix: String = "",
    postfix: String = ""
) {
    // . . .
}
```

위와 같이 컬렉션에 대한 확장을 만들 수 있다

<br>

### 3.3.4 확장 함수는 오버라이드할 수 없다

- 확장 함수는 클래스의 일부가 아닌, 클래스 밖에 선언된다
- 코틀린은 호출될 확장 함수를 정적으로 결정한다
- 따라서 확장 함수를 오버라이브할 수는 없다

<br>

### 3.3.5 확장 프로퍼티

```kotlin
val String.lastChar: Char
    get() = get(length - 1)
```

- 확장 프로퍼티 또한 일반적인 프로퍼티와 동일하되, 단지 수신 객체 클래스가 추가됐을 뿐이다
- 뒷받침하는 필드가 없기 때문에 기본 게터 구현을 제공할 수 없으므로 최소한 게터는 꼭 정의해야 한다
- 마찬가지로 초기화 코드에서 계산한 값을 담을 장소가 없으므로 초기화 코드도 쓸 수 없다
  
<br>

## 3.4 컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원

<br>

### 3.4.2 가변 인자 함수: 인자의 개수가 달라질 수 있는 함수 정의

- vararg 키워드를 사용하면 호출 시 인자 개수가 달라질 수 있는 함수를 정의할 수 있다

```kotlin
fun listOf<T> (vararg values: T) List<T> { . . . }
```

<br>

### 3.4.3 값의 쌍 다루기: 중위 호출과 구조 분해 선언

```kotlin
1.to("one") // "to" 메서드를 일반적인 방식으로 호출
1 to "one" // "to" 메서드를 중위 호출 방식으로 호출
```

- 인자가 하나뿐인 일반 메서드나 인자가 하나뿐인 확장 함수에 중위 호출을 사용할 수 있다
- 함수를 중위 호출에 사용하게 허용하고 싶으면 infix 변경자를 함수 선언 앞에 추가하면 된다

```kotlin
infix fun Any.to(other: Any) = Pair(this, other)
```

- 구조 분해 선언 예시
    - `val (number, name) = 1 to "one"`
    - `for ((index, element) in collection.withIndex()) {}`
  
<br>

## 3.5 문자열과 정규식 다루기

<br>

## 3.5.1 문자열 나누기

- JAVA에서 `"12.345-6.A".split(".")`의 호출 결과는 `[12, 345-6, A]`가 아닌 `[]`이다
  - JAVA의 `split()` 구분 문자열은 실제로는 정규식이기 때문이다
  - 이때 마침표(.)는 모든 문자를 나타내는 정규식으로 해석된다
  
<br>

## 3.5.2 정규식과 3중 따옴표로 묶은 문자열

- `substringBeforeLast("/")` 와 같은 메서드들을 사용하여 정규식 대신 코틀린 메서드로 대체할 수 있다
  
<br>

## 3.5.3 여러 줄 3중 따옴표 문자열

- 멀티라인 또는 이스케이프 문자가 포함된 문자열의 경우, `"""`와 같이 3중 따옴표 문자열을 사용하여 쉽게 표현할 수 있다

<br>

## 3.6 코드 다듬기: 로컬 함수와 확장

- 코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다
- 로컬 함수는 자신이 속한 바깥 함수의 모든 파라미터와 변수를 사용할 수 있다
- 확장 함수를 로컬 함수로 정의할 수도 있으나, 중첩된 함수의 깊이가 깊어지면 코드 가독성이 떨어진다